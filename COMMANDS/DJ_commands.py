from ..DJbooth.DJ import *
from ..imports import *

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from coord import Coord
    from maps.base import Map
    from tiles.base import MapObject
    from tiles.map_objects import *
    from command import MenuCommand

import random
from typing import List
# DJ Command Classes using the Command Pattern

class DJPlayCommand(MenuCommand):
    """
    A command that triggers the DJ booth to play music.
    """
    name: str = 'play'
    
    def __init__(self, dj_booth: DJ) -> None:
        """
        Initializes the command with the singleton DJ instance.

        @Preconditions:
            - dj_booth must be an instance of DJ
        """
        assert isinstance(dj_booth, DJ), "dj_booth must be an instance of DJ"
        self.dj_booth: DJ = dj_booth

    def execute(self, context: "Map", player: "HumanPlayer") -> List[Message]:
        """
        Executes the play command for the DJ booth.

        @Parameters:
            context: The current game map
            player: The human player triggering this command

        @Returns:
            A list of Message objects generated by the DJ booth
        @Postconditions:
            - Returns an empty list if no message is produced
        """
        sound_msg = self.dj_booth.play(player)
        return sound_msg if sound_msg is not None else []


class DJNextCommand(MenuCommand):
    """
    A command that triggers the DJ booth to play the next song
    """
    name: str = 'next'
    
    def __init__(self, dj_booth: DJ) -> None:
        """
        Initializes the command with a DJ instance.

        @Preconditions:
            - dj_booth must be an instance of DJ
        """
        assert isinstance(dj_booth, DJ), "dj_booth must be an instance of DJ"
        self.dj_booth: DJ = dj_booth

    def execute(self, context: "Map", player: "HumanPlayer") -> List[Message]:
        """
        Executes the next command for the DJ booth

        @Returns:
            A list of Message objects from playing the next song
        """
        msg = self.dj_booth.next_song(player)
        return msg if msg is not None else []


class DJPreviousCommand(MenuCommand):
    """
    A command that triggers the DJ booth to play the previous song.
    """
    name: str = 'previous'
    
    def __init__(self, dj_booth: DJ) -> None:
        """
        Initializes the command with a DJ instance

        Preconditions:
            - dj_booth must be an instance of DJ
        """
        assert isinstance(dj_booth, DJ), "dj_booth must be an instance of DJ"
        self.dj_booth: DJ = dj_booth

    def execute(self, context: "Map", player: "HumanPlayer") -> List[Message]:
        """
        Executes the previous command for the DJ booth

        Returns:
            A list of Message objects from playing the previous song
        """
        msg = self.dj_booth.previous_song(player)
        return msg if msg is not None else []


class DJShuffleCommand(MenuCommand):
    """
    A command that triggers the DJ booth to shuffle the playlist
    """
    name: str = 'shuffle'
    
    def __init__(self, dj_booth: DJ) -> None:
        """
        Initializes the command with a DJ instance

        @Preconditions:
            - dj_booth must be an instance of DJ
        """
        assert isinstance(dj_booth, DJ), "dj_booth must be an instance of DJ"
        self.dj_booth: DJ = dj_booth

    def execute(self, context: "Map", player: "HumanPlayer") -> List[Message]:
        """
        Executes the shuffle command for the DJ booth.

        @Returns:
            A list of Message objects from shuffling the playlist
        """
        msg = self.dj_booth.shuffle(player)
        return msg if msg is not None else []